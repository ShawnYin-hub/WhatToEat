# 修复无限递归错误说明

## 错误信息

```
infinite recursion detected in policy for relation "rooms"
```

这个错误是因为 RLS（Row Level Security）策略中出现了循环依赖：
- `rooms` 表的策略查询 `room_members` 表
- `room_members` 表的策略可能又查询 `rooms` 表
- 形成无限循环

## 解决方案

### 方案 1：使用 SECURITY DEFINER 函数（推荐）

**执行文件：** `database/fix_infinite_recursion.sql`

这个方案：
1. 创建一个 `SECURITY DEFINER` 函数来检查用户是否是房间成员
2. 这个函数可以绕过 RLS，避免递归
3. 在策略中使用这个函数来检查权限

**执行步骤：**
1. 登录 Supabase Dashboard
2. 打开 SQL Editor
3. 复制 `database/fix_infinite_recursion.sql` 的全部内容
4. 粘贴并执行

### 方案 2：简化策略（如果方案 1 不行）

**执行文件：** `database/fix_infinite_recursion_simple.sql`

这个方案：
1. 只允许 host 直接查看房间
2. 成员需要通过其他方式获取房间信息
3. 完全避免递归问题

**注意：** 如果使用这个方案，可能需要修改前端代码，让成员通过 `room_members` 表来获取房间信息。

## 执行步骤

### 第一步：执行修复脚本

1. **登录 Supabase Dashboard**
   - 打开你的项目

2. **打开 SQL Editor**
   - 左侧菜单点击 **SQL Editor**
   - 点击 **New query**

3. **执行修复脚本**
   - 先尝试执行 `database/fix_infinite_recursion.sql`
   - 如果还有问题，再执行 `database/fix_infinite_recursion_simple.sql`

4. **验证执行结果**
   - 应该看到 "Success" 消息
   - 如果有错误，请告诉我具体的错误信息

### 第二步：测试

1. **刷新应用页面**
2. **尝试加入房间**
   - 输入房间码
   - 点击加入
3. **检查浏览器控制台**
   - 应该不再有 500 错误
   - 应该不再有递归错误

## 如果还有问题

### 检查当前策略

在 SQL Editor 中执行：

```sql
-- 查看当前 rooms 表的所有策略
SELECT 
  schemaname,
  tablename,
  policyname,
  permissive,
  roles,
  cmd,
  qual,
  with_check
FROM pg_policies 
WHERE tablename = 'rooms'
ORDER BY policyname;
```

### 检查函数是否存在

```sql
-- 查看函数是否存在
SELECT 
  proname as function_name,
  pg_get_function_arguments(oid) as arguments
FROM pg_proc
WHERE proname = 'is_room_member';
```

### 完全重置（最后手段）

如果所有方法都不行，可以完全重置策略：

```sql
-- 删除所有策略
DROP POLICY IF EXISTS "Users can view rooms they are in" ON rooms;
DROP POLICY IF EXISTS "Members can view their rooms" ON rooms;
DROP POLICY IF EXISTS "Users can create rooms" ON rooms;
DROP POLICY IF EXISTS "Hosts can update own rooms" ON rooms;

-- 删除函数
DROP FUNCTION IF EXISTS is_room_member(UUID);
DROP FUNCTION IF EXISTS check_user_can_view_room(UUID);

-- 重新创建最简单的策略
CREATE POLICY "Users can view rooms they are in" ON rooms
  FOR SELECT USING (host_id = auth.uid());

CREATE POLICY "Users can create rooms" ON rooms
  FOR INSERT WITH CHECK (auth.uid() = host_id);

CREATE POLICY "Hosts can update own rooms" ON rooms
  FOR UPDATE USING (host_id = auth.uid()) WITH CHECK (host_id = auth.uid());
```

## 工作原理

### SECURITY DEFINER 函数

`SECURITY DEFINER` 函数以函数创建者的权限运行，而不是调用者的权限。这意味着：
- 函数内部可以绕过 RLS 策略
- 不会触发递归检查
- 可以安全地查询其他表

### 策略中的函数调用

在 RLS 策略中调用 `SECURITY DEFINER` 函数：
- 函数执行时不会触发表的 RLS 策略
- 避免了循环依赖
- 保持了安全性（函数内部仍然检查用户权限）

## 需要帮助？

如果问题还没解决，请提供：
1. Supabase SQL Editor 执行后的完整输出
2. 浏览器控制台的完整错误信息
3. 执行 `SELECT * FROM pg_policies WHERE tablename = 'rooms';` 的结果
